\chapter{Various}

%\section{Intervals}
%	\kactlimport{IntervalContainer.h}
%	\kactlimport{IntervalCover.h}
%	\kactlimport{ConstantIntervals.h}

\section{Misc. algorithms}
	\kactlimport{TernarySearch.h}
	%\kactlimport{LIS.h}

\section{Dynamic programming}
	\kactlimport{KnuthDP.h}
%	\kactlimport{DivideAndConquerDP.h}

	\kactlimport{FastMod.h}
	\kactlimport{FastInput.h}
	%\kactlimport{BumpAllocator.h}
	%\kactlimport{SmallPtr.h}
	%\kactlimport{BumpAllocatorSTL.h}
	% \kactlimport{Unrolling.h}
	%\kactlimport{SIMD.h}
\section{Techniques}
\underline{\textbf{min-weight vertex cover in a bipartite graph}}: partition into A and B. add edges $s \rightarrow A$ with capacities $w(A)$ and edges $B \rightarrow t$ with capacities $w(B)$. add edges of capacity $\infty$ from A to B where there are edges in the graph. answer is maxflow. the vertex cover is the set of nodes that are
adjacent to cut edges, or alternatively, the left-side nodes NOT reachable from the source and the right-side edges reachable from the source (in the residual network).\\
\underline{\textbf{Bipartite Graph}}: Min Cover (fewest nodes cover all edges) = max matching. Min path covering for DAG: n - maxmatching. Min dominating set = max matching + isolated nodes. Max independent set = n - max matching\\
\underline{\textbf{Bipartite matching with weights on the left-hand nodes}}, minimizing the matched weight sum:
   sort left-hand nodes ascending by weight, then just use the normal bipartite matching algorithm (Kuhn's)\\
   \underline{\textbf{Closure problem}}: Find a subset $V' \subset V$ such that $V'$ is closed (every successor of a node in $V'$ is also in $V'$) and such that $\sum_{v \in V'} w(v)$ is maximal under all such subsets $V'$. We use min-cut: for every node $v$, if $w(v) > 0$, add an edge $(S, v)$ with capacity $w(v)$, otherwise add edge $(v,T)$ with capacity $-w(v)$. Add edges $(v,w)$ with capacity $\infty$ for all edges $(v,w)$ in the original graph. The source partition of the min-cut is the optimal $V'$.\\
   \underline{\textbf{Poset width / partition into maximum number of chains}}: Duplicate each element
in $\{0,\ldots,n-1\}$, add edge $(u, n+v)$ for $u < v$. Edges in maximum matching in the
resulting bipartite graph correspond to chain edges. Width is n - max matching.
For weighted nodes, duplicate elements so they form an antichain.\\
\underline{\textbf{Erdős–Gallai theorem}}: A sequence of non-negative integers $d_1\geq\cdots\geq d_n$ can be represented as the degree sequence of a finite simple graph on $n$ vertices if and only if $d_1+\cdots+d_n$ is even and $\sum^{k}_{i=1}d_i\leq k(k-1)+ \sum^n_{i=k+1} \min(d_i,k) \ \forall\ 1 \leq k \leq n$\\
\underline{\textbf{Capacity constraints without sink}}:feasible flow in a network with both upper and lower capacity constraints, no source or sink : capacity are changed to upperbound-lowerbound. Add a new source and a sink. let M[v] = (sum of lowerbounds of ingoing edges to v) - (sum of lowserbounds of outgoing edges from v). For all v, if M[v]>0 then add edge (S,v) with capacity M, otherwise add (v,T) with capacity -M. If all outgoing edges from S are full, then a feasible flow exists, it is the flow plus the original lowerbounds.\\
\underline{\textbf{Capacity constraints with sink}}: feasible flow in a network with both upper and lower capacity constraints, with source s and sink t: add edge (t,s) with capacity infinity. Binary search for the lower bound, check whether a feasible exists for a network WITHOUT source or sink (B).
